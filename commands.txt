Notes:
This file should be viewed with code page 437 encoding (CP437, OEM-437, and OEM-US are common names for it)
There are 4 data types in Seriously: numeric, string, list, and function.
a represents any value. This usually means numeric values, but can represent any value of a type not specified in an alternate command definition.
"a" represents a string value.
[a] represents a list value.
z represents a complex value. Complex values are a proper subset of numeric values.
f represents a function value.
Some commands have fixed arity. Others have variable arity. This is denoted by the number of values listed in the pop. Those commands that are not functional commands (such as delimiters) do not have arities, and so do not pop from the stack.
Each functional command operates differently based on the data types of the values popped from the stack. In some cases, that order matters. In others, it does not. Each operation will be denoted by the different data types popped. If there is a conflict, the most restrictive applicable definition is used.
When possible, the character at each code point is listed in parentheses following the ordinal. For non-printing characters (ordinals 1-31), this is not possible, so a description is provided instead.

1 (SOH):
2 (STX):
3 (ETX):
4 (EOT):
5 (ENQ):
6 (ACK):
7 (bell):
8 (backspace):
9 (tab):
10 (line feed):
11 (vertical tab):
12 (form feed):
13 (carriage return):
14 (SO):
15 (SI):
16 (DLE):
17 (DC1):
18 (DC2):
19 (DC3):
20 (DC4):
21 (NAK):
22 (SYN):
23 (ETB):
24 (CAN):
25 (EM):
26 (SUB):
27 (ESC):
28 (FS):
29 (GS):
30 (RS):
31 (US):
32 ( ): push the # of elements on the stack (push len(stack))
33 (!): pop a: push a! (factorial(a))
34 ("): string literal, reads until next " and pushes value onto stack. An implied " is present at EOF if needed.
35 (#): pop a: push list(a)
36 ($): pop a: push str(a)
37 (%): pop a,b: push a%b; pop "a",[b]: push "a"%[b]
38 (&): pop a,b: push (a & b)
39 ('): pushes next character onto stack as character literal (length-1 string)
40 ((): rotates stack right by 1
41 ()): rotates stack left by 1
42 (*): pop a,b: push a*b; pop "a",b: repeat "a" b times, push "a" ("a"*b)
43 (+): pop a,b: push a+b; pop "a","b": push concatenation of "a" and "b"; pop [a],[b]: push [a][b] (append [b] to [a])
44 (,): read value from stdin and push
45 (-): pop a,b: push a-b
46 (.): pop a: write a to stdout; pop f: f. (call f and execute . recursively)
47 (/): pop a,b: push a/b (float division); pop [a]: rotate [a] right by 1, push [a]
48 (0): push 0
49 (1): push 1
50 (2): push 2
51 (3): push 3
52 (4): push 4
53 (5): push 5
54 (6): push 6
55 (7): push 7
56 (8): push 8
57 (9): push 9
58 (:): numeric literal delimiter: pushes the string between it and the following : as a numeric value, or 0 if it cannot be converted. An implicit : is present at EOF if needed.
59 (;): pop a: push a,a
60 (<): pop a,b: push 1 if a<b else 0
61 (=): pop a,b: push 1 if a==b else 0
62 (>): pop a,b: push 1 if a>b else 0
63 (?): NOP, extended expressions if -e flag is passed
64 (@): pop a,b: push a,b (rotate top 2 elements)
65 (A): pop a: push abs(a)
66 (B): pop a,b: push a random integer in [a,b) (randrange(a,b))
67 (C): pop a: push cos(a)
68 (D): pop a: push a-1
69 (E): pop a: push erf(a)
70 (F): pop a: push Fib(a) (Fib(0)=0, Fib(1)=Fib(2)=1)
71 (G): push a random float in the range [0,1) (push random())
72 (H): if stack is empty: print "Hello, World!" to stdout
73 (I): pop a,b,c: push b if a is truthy, else push c
74 (J): pop a: push a random integer in [0,a) (randrange(a)); pop [a] or "a": push a random element from [a] or "a" (random.choice([a]|"a"))
75 (K): pop a: push ceil(a)
76 (L): pop a: push floor(a)
77 (M): pop f,[a], execute f for each element in [a], using the element as a temporary stack, push [a] (similar to map(f,[a]))
78 (N): if stack is empty: print the lyrics to "99 Bottles of Beer" to stdout
79 (O): pop "a" or [a]: push ord(c) for each c in "a" or [a], starting from the end. If a list is popped and it contains strings of length > 1, the strings are exploded in-place (["ABC"] -> [65,66,67], [["A","B","CD"]] -> [65,66,67,68])
80 (P): pop a: push the a-th prime (zero-indexed)
81 (Q): if stack is empty: print the program's source code to stdout
82 (R): pop f,[a]: call f, using [a] as a temporary stack, push [a] (similar to reduce(f,[a])); pop "a" or [a]: push reversed value ("a".reverse() or [a][::-1]); pop a: push [1,2,...,a] (range(1,a+1))
83 (S): pop a: push sin(a)
84 (T): pop a: push tan(a)
85 (U): pop [a],[b]: push union of [a] and [b]
86 (V): pop a,b: push uniform(a,b) (random float between a and b)
87 (W): loop delimiter: peek top of stack, repeat code in loop while a evaluates to true
88 (X): pop a: discard
89 (Y): pop a: push !bool(a) (logical negate, opposite of b)
90 (Z): pop [a],[b]: push zip([a],[b])
91 ([): begin list literal, values are delimited by commas (,)
92 (\): pop a,b: push a/b (integer division); pop [a]: rotate [a] left by 1, push [a]
93 (]): end list literal
94 (^): pop a,b: push pow(a,b)
95 (_): pop a: push ln(a)
96 (`): function literal delimiter, pushes function whose body contains all of the commands until the next `. An implied ` is present at EOF if needed.
97 (a): invert the stack ([a,b,c,d] -> [d,c,b,a])
98 (b): pop a: push 0 if a==0 else 1; pop "a" or [a]: push 0 if len(a)==0 else 1; pop f: push 0 if len(f)==0 else 1
99 (c): pop a: push character at ordinal a%256
100 (d): pop [a]: dequeue b from [a], push [a],b
101 (e): pop a: push exp(a)
102 (f): pop a: push the Fibonacci index of a if a is a Fibonacci number, else -1; pop "a",[b]: push "a".format(*[b])
103 (g): pop a,b: push gcd(a,b)
104 (h): pop a,b: push sqrt(a*a+b*b) (Euclidean norm)
105 (i): pop "a": push atof(a); pop [a]: push each element from [a], starting from end (flatten)
106 (j): pop "a",[b]: push "a".join([b]) (converting values in [b] to strings with $ if necessary)
107 (k): pop all elements from stack, convert to list (in the order they were on the stack, starting from the top), and push
108 (l): pop "a" or [a] or f: push len(a) (or len(f))
109 (m): pop a: push int(a),frac(a) (modf(a))
110 (n): pop a,b: push a b times; pop f,b: call f b times
111 (o): pop [a],b: push b to [a], push [a]
112 (p): pop a: push 1 if a is prime else 0; pop [a]: pop b from [a], push [a],b
113 (q): pop [a],b: enqueue b in [a], push [a]
114 (r): pop "a": push each character in "a", starting from the end (explode string); pop a: push [0,1,...,a-1] (range(0,a))
115 (s): pop a: push sgn(a)
116 (t): pop all elements from stack, flatten any lists and explode any strings, and push them in the same order they were popped (full stack flatten/explode)
117 (u): pop a: push a+1
118 (v): pop a: seed the RNG with a (random.seed(a))
119 (w): pop a: push the full factorization of a (18 -> [[2,1],[3,2]])
120 (x): pop a,b: push [a,b) (range(a,b))
121 (y): pop a: push the prime factors of a (18 -> [2,3])
122 (z): pop a: repeat . a times (pop a times and print to stdout)
123 ({): pop a: rotate stack right a times
124 (|): pop a,b: push (a | b)
125 (}): pop a: rotate stack left a times
126 (~): pop a: push ~a (unary bitwise negate)
127 (): terminate the program
128 (€): pop a,b: push a+bi; pop [a]: pop pairs of real numerics b,c from [a] and push b+ci (appending 0 to [a] if len([a]) is odd)
129 (): pop entire stack and print to stdout
130 (‚): pop entire stack (clear stack)
131 (ƒ): pop a: push asin(a)
132 („): pop a: push acos(a)
133 (…): pop a: push atan(a)
134 (†): pop a,b: push atan2(a,b)
135 (‡): pop a: push asinh(a)
136 (ˆ): pop a: push acosh(a)
137 (‰): pop a: push atanh(a)
138 (Š):
139 (‹): push i, the imaginary unit (sqrt(-1) or 0+1i)
140 (Œ): pop a, push 0+ai
141 ():
142 (Ž): pop a: push sinh(a)
143 (): pop a: push cosh(a)
144 (): pop a: push tanh(a)
145 (‘):
146 (’):
147 (“):
148 (”):
149 (•):
150 (–):
151 (—):
152 (˜):
153 (™):
154 (š):
155 (›): pop a,b: push abs(a)*sgn(b)
156 (œ):
157 ():
158 (ž): pop z: push phase(z)
159 (Ÿ): pop f: call f
160 ( ): pop z: push the complex conjugate of z
161 (¡):
162 (¢):
163 (£):
164 (¤):
165 (¥):
166 (¦): pop a: push a*a
167 (§): pop a: push degrees(a)
168 (¨):
169 (©): pop a: push a+2
170 (ª): pop a: push a-2
171 («): pop a: push a/2 (division style determined by if a is integer or float)
172 (¬): pop a: push a/4 (division style determined by if a is integer or float)
173 (­):
174 (®): pop a,b: insert b at position a, indexed from the bottom of the stack
175 (¯): pop a,b: insert b at position a, indexed from the top of the stack
176 (°):
177 (±):
178 (²):
179 (³): duplicate stack ([a,b,c] => [a,b,c,a,b,c])
180 (´):
181 (µ):
182 (¶):
183 (·):
184 (¸):
185 (¹):
186 (º):
187 (»):
188 (¼):
189 (½):
190 (¾):
191 (¿):
192 (À):
193 (Á):
194 (Â):
195 (Ã):
196 (Ä):
197 (Å): duplicate each element on stack ([a,b,c] => [a,a,b,b,c,c])
198 (Æ):
199 (Ç):
200 (È):
201 (É):
202 (Ê):
203 (Ë): push pi
204 (Ì): push e
205 (Í):
206 (Î):
207 (Ï):
208 (Ð):
209 (Ñ):
210 (Ò):
211 (Ó):
212 (Ô):
213 (Õ):
214 (Ö):
215 (×):
216 (Ø):
217 (Ù):
218 (Ú):
219 (Û):
220 (Ü):
221 (Ý):
222 (Þ):
223 (ß):
224 (à):
225 (á):
226 (â): pop a: push Gamma(a)
227 (ã): pop [a]: push product([a])
228 (ä): pop [a]: push sum([a])
229 (å):
230 (æ):
231 (ç):
232 (è):
233 (é):
234 (ê):
235 (ë):
236 (ì):
237 (í): push phi (golden ratio)
238 (î):
239 (ï): pop [a],[b]: push intersection of [a] and [b]
240 (ð):
241 (ñ): pop a: push -a (unary negate)
242 (ò): pop a,b: push a>=b
243 (ó): pop a,b: push a<=b
244 (ô):
245 (õ):
246 (ö):
247 (÷): pop a: push int(a)
248 (ø): pop a: push radians(a)
249 (ù):
250 (ú):
251 (û): pop a: push sqrt(a)
252 (ü):
253 (ý):
254 (þ):
255 (ÿ):
